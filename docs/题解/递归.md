# 递归

对于递归，不能想太复杂，只需要考虑三要素：

- 终止条件
- 每层方法终止时的返回值
- 本层方法需要执行的操作

递归就是一层一层向下挖掘，再将结果一层一层向上返回

## **涉及链表的递归**

### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)（Easy）

> 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
>
> 示例：
>
> 输入：1->3, 2->4
> 输出：1->2->3->4

终止条件：链表到达终点，即一条链表的节点为null，另一条链表的当前节点就为返回值

本层方法需要执行的操作：将参数中较小的值指向下一层方法，下一层方法的参数为：较小值的下一节点和另一链表的当前节点，下一层方法判断哪个值更小，最后就会形成一个有序的链表

![未命名文件(7)](C:\Users\csj\Downloads\未命名文件(7).jpg)

```JAVA
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    if (l1 == null) {
        //l1都等于null了，肯定是l2更大呀
        return l2;
    }
    if (l2 == null) {
        return l1;
    }
    if (l1.val < l2.val) {
        l1.next = mergeTwoLists(l1.next, l2);//修改l1的下一节点
        return l1;
    } else {
        l2.next = mergeTwoLists(l1, l2.next);
        return l2;
    }
}
```

### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)（Easy）

> 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。
>
> 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
>
> 示例:
>
> 给定 1->2->3->4, 你应该返回 2->1->4->3.
>

```java
public ListNode swapPairs(ListNode head) {
    //当链表到终点或只剩1个节点时，结束递归
    if (head == null || head.next == null) {
        return head;
    }
    //因为要修改head的next，所以先暂存
    ListNode next = head.next;
    //修改head的next节点，指向之后修改好的节点
    head.next = swapPairs(next.next);
    //原来的next指向head，就完成了交换
    next.next = head;
    //最后的next就是头节点
    return next;
}
```

