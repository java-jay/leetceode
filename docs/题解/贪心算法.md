# 贪心算法

直到找到符合条件的，再进行处理

### [605. 种花问题](https://leetcode-cn.com/problems/can-place-flowers/)（Easy）

> 假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。
>
> 给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。
>
> 示例 1:
>
> 输入: flowerbed = [1,0,0,0,1], n = 1
> 输出: True
>
> 示例 2:
>
> 输入: flowerbed = [1,0,0,0,1], n = 2
> 输出: False
>
> 注意:
>
> 数组内已种好的花不会违反种植规则。
> 输入的数组长度范围为 [1, 20000]。
> n 是非负整数，且不会超过输入数组的大小。

```java
public static boolean canPlaceFlowers(int[] flowerbed, int n) {
    //每种一棵树，n-1，在外层循环要添加n>0的判断，一旦树种完，就结束循环
    for (int i = 0; i < flowerbed.length && n > 0; i++) {
        //当前位置没有树，且相邻地块没有树
        if (flowerbed[i] == 0 && (i == 0 || flowerbed[i - 1] == 0) && (i == flowerbed.length - 1 || flowerbed[i + 1] == 0)) {
            n--;
            flowerbed[i] = 1;
        }
    }
    return n == 0;
}
```

### [665. 非递减数列](https://leetcode-cn.com/problems/non-decreasing-array/)（Easy）

> 给定一个长度为 n 的整数数组，你的任务是判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。
>
> 我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 <= i < n)，满足 array[i] <= array[i + 1]。
>
> 示例 1:
>
> 输入: [4,2,3]
> 输出: True
> 解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。
>
> 示例 2:
>
> 输入: [4,2,1]
> 输出: False
> 解释: 你不能在只改变一个元素的情况下将其变为非递减数列。
>
> 说明:  n 的范围为 [1, 10,000]。
>

2种可能：

1.数组为2,4,3，应该修改为2,3,3或者2,4,4，把大的值改小或者把小的值改大都可以，条件是n+1<n，且n+1>n-1

2.数组为2,3,1，应该修改为2,3,3，只能把小的值改大，条件是n+1<n，且n+1<n-1

因此第一种情况只要标记一下，第二种情况还需要把值改了，因为要确保修改后的大值仍然比后续的值小

```java
public boolean checkPossibility(int[] nums) {
    if (nums.length < 3) {
        return true;
    }
    int count = 0;
    for (int i = 0; i < nums.length - 1; i++) {
        //找到第一个<前一个数的值
        if (nums[i + 1] < nums[i]) {
            //如果有至少2个数需要修改，就直接返回false
            count++;
            if (count > 1) {
                return false;
            }
            //如果i+1的值同时小于i-1的值和i的值，让i+1的值与i的值相等，确保修改后的大值仍然比后续的值小
            if (i > 0 && nums[i + 1] < nums[i - 1]) {
                nums[i + 1] = nums[i];
            }
        }
    }
    return true;
}
```

### [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)（Easy）

> 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
>
> 注意：
>
> 你可以假设胃口值为正。
> 一个小朋友最多只能拥有一块饼干。
>
> 示例 1:
>
> 输入: [1,2,3], [1,1]
>
> 输出: 1
>
> 解释: 
> 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
> 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
> 所以你应该输出1。
>
> 示例 2:
>
> 输入: [1,2], [1,2,3]
>
> 输出: 2
>
> 解释: 
> 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
> 你拥有的饼干数量和尺寸都足以让所有孩子满足。
> 所以你应该输出2.

```java
public int findContentChildren(int[] g, int[] s) {
    //从胃口最小的开始找，先进行排序
    Arrays.sort(g);
    Arrays.sort(s);
    int i = 0, j = 0, count = 0;
    while (i < g.length && j < s.length) {
        //如果最小的尺寸满足最小的胃口
        if (s[j] >= g[i]) {
            count++;
            //胃口指针右移
            i++;
        }
        //尺寸指针右移
        j++;
    }
    return count;
}
```

### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

> 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
>
> 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。
>
> 注意你不能在买入股票前卖出股票。
>
> 示例 1:
>
> 输入: [7,1,5,3,6,4]
> 输出: 5
> 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
>      注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
>
> 示例 2:
>
> 输入: [7,6,4,3,1]
> 输出: 0
> 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

```java
public int maxProfit(int[] prices) {
    if (prices.length == 0) {
        return 0;
    }
    int min = prices[0], profit = 0;
    for (int i = 1; i < prices.length; i++) {
        if (prices[i] > min) {
            //如果当前值小于最小值，就计算当前收益是否为最大收益
            profit = Math.max(prices[i] - min, profit);
        } else {
            //找到最小值
            min = prices[i];
        }
    }
    return profit;
}
```

### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

> 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
>
> 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
>
> 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>
> 示例 1:
>
> 输入: [7,1,5,3,6,4]
> 输出: 7
> 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
>      随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
>
> 示例 2:
>
> 输入: [1,2,3,4,5]
> 输出: 4
> 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
>      注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
>      因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
>
> 示例 3:
>
> 输入: [7,6,4,3,1]
> 输出: 0
> 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

```java
public int maxProfit(int[] prices) {
    int profit = 0;
    for (int i = 1; i < prices.length; i++) {
        //只要后面的数更大，利润就加上这个差值，最后总是最大的值-最小的值，例如（b-a）+（c-b）=c-a
        if (prices[i] > prices[i - 1]) {
            profit += (prices[i] - prices[i - 1]);
        }
    }
    return profit;
}
```

