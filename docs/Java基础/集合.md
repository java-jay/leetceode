# 集合

## 集合源码

### ArrayList

继承了AbstractList，实现了List，RandomAccess，Cloneable，Serializable

RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持**快速随机访问**的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。

和 Vector 不同，**ArrayList 中的操作不是线程安全的**！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者  CopyOnWriteArrayList。

```java
private static final int DEFAULT_CAPACITY = 10;//默认初始容量为10
```

```java
private static final Object[] EMPTY_ELEMENTDATA = {};//用于空实例的空数组
```

```java
 //用于默认大小空实例的共享空数组实例。
 //把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时，容量需要扩容多少
 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
```

```java
//存储元素的数组缓冲区，ArrayList的容量是缓冲区的长度，任何以elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA的空ArrayList将会在添加第一个元素时，被扩容到默认的容量
//采用transient的原因：避免将数组中的空元素也序列化，而在下面的writeObject方法进行了序列化elementData的方法
transient Object[] elementData;
```

```java
private int size;//集合中的元素个数
```

```java
//带参数构造方法
public ArrayList(int initialCapacity) {
    if (initialCapacity > 0) {
    //按指定的容量创建一个数组
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {//传入参数为0，创建一个空集合
        this.elementData = EMPTY_ELEMENTDATA;
    } else {//传入参数小于0，抛出异常
        throw new IllegalArgumentException("Illegal Capacity: "+
                                           initialCapacity);
    }
}

//不带参数的构造方法，初始化容量是0，添加第一个元素后被扩容至默认容量
 public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }

//参数为集合的构造方法
public ArrayList(Collection<? extends E> c) {
    //缓冲数组为参数转换成的数组
        elementData = c.toArray();
    //如果元素个数不等于0
        if ((size = elementData.length) != 0) {
            //如果toArray()后的数组不是Object类型数组，就将数组复制到一个Object数组中
            //例如Arrays.asList("foo", "bar").toArray()返回的是String[]
            if (elementData.getClass() != Object[].class)
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // 如果元素个数为0，就让这个集合为空集合
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }

```

关于Arrays.asList()方法：

**返回的 List 是一个不可变长度的列表，此列表不再具备原 List 的很多特性**

如果传入一个有多个元素的int[]数组，其list的size()也只会输出1，因为它会把整个int[]当做引用类型，使用Integer[]可避免该问题

```java
//集合容量过大，用于修剪集合
public void trimToSize() {
        modCount++;//后面再提
        if (size < elementData.length) {//如果当前集合大小小于缓冲数组的长度
            //如果集合为空，缓冲数组就为空，否则就复制到一个新的，长度为当前集合大小的数组中
            elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size);
        }
    }
```

```java
//通过所需要的最小容量进行扩容，这个方法是可以由外部调用的
public void ensureCapacity(int minCapacity) {
    //如果当前缓冲数组有内容，最小扩容量就为默认容量
        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) ? 0 : DEFAULT_CAPACITY;
    //如果所需要的最小容量大于最小扩容量
        if (minCapacity > minExpand) {
            //扩容
            ensureExplicitCapacity(minCapacity);
        }
    }
	//计算所需要的最小容量
    private static int calculateCapacity(Object[] elementData, int minCapacity) {
        //如果缓冲数组为空，返回默认容量和所需要的最小容量的最大值
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            return Math.max(DEFAULT_CAPACITY, minCapacity);
        }
        return minCapacity;
    }
	//进行扩容
    private void ensureCapacityInternal(int minCapacity) {
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    }

    private void ensureExplicitCapacity(int minCapacity) {
        modCount++;
		//如果需要扩容，就用所需要的最小容量进行扩容
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }


public boolean add(E e) {
    //当添加第一个元素时，传入参数为1，比默认容量小，所以是按所需要的最小容量为10进行扩容的
    //在grow方法中，旧容量为0，新容量为0*1.5=0，再变为10
    //所以空的构造方法创建的集合在添加第一个元素后会扩容到10
        ensureCapacityInternal(size + 1);
    //对集合末端进行赋值，也就是数组末尾的赋值
        elementData[size++] = e;
        return true;
    }

public void add(int index, E element) {
    //判断索引是否在0-size的范围中
        rangeCheckForAdd(index);
	//判断是否需要扩容
        ensureCapacityInternal(size + 1); 
    //进行自我复制，将index到size的范围的元素都右移一位
        System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
    //当前索引进行赋值
        elementData[index] = element;
    //元素个数+1    
    	size++;
    }

private void rangeCheckForAdd(int index) {
        if (index > size || index < 0)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }
```

```java
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;	//能够分配的最大数组空间的大小
```

```java
//核心方法
private void grow(int minCapacity) {
        // 旧容量
        int oldCapacity = elementData.length;
    	//新容量=旧容量+旧容量/2=旧容量*1.5
        int newCapacity = oldCapacity + (oldCapacity >> 1);
   	 	//检查新容量是否大于最小需要容量，如果还是小于最小需要容量，那么就把最小需要容量当作数组的新容量
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
    	//如果新容量大于最大容量，且最小需要容量大于最大容量，新容量就为Integer的最大值
    	//如果新容量大于最大容量，且最小需要容量不大于最大容量，新容量等于最大容量
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        //将原有数组复制到新容量大小的数组
        elementData = Arrays.copyOf(elementData, newCapacity);
    }

private static int hugeCapacity(int minCapacity) {
        if (minCapacity < 0) 
            throw new OutOfMemoryError();
        return (minCapacity > MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;
}
```

```java
//从左到右线性查找集合匹配的第一个索引
public int indexOf(Object o) {
        if (o == null) {
            for (int i = 0; i < size; i++)
                if (elementData[i]==null)
                    return i;
        } else {
            for (int i = 0; i < size; i++)
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1;
    }
//从右到左线性查找集合匹配的最后一个索引
 public int lastIndexOf(Object o) {
        if (o == null) {
            for (int i = size-1; i >= 0; i--)
                if (elementData[i]==null)
                    return i;
        } else {
            for (int i = size-1; i >= 0; i--)
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1;
    }
```

```java
//浅拷贝
public Object clone() {
        try {
            ArrayList<?> v = (ArrayList<?>) super.clone();
            //只实现了整个数组的复制，没有对数组中的对象进行拷贝（例如ArrayList<List<String>>中的String）
            v.elementData = Arrays.copyOf(elementData, size);
            v.modCount = 0;
            return v;
        } catch (CloneNotSupportedException e) {
            // this shouldn't happen, since we are Cloneable
            throw new InternalError(e);
        }
    }
```

```java
//转为数组的方式也是再复制一个数组，这个数组是安全的，原list不对其有引用，可以任意修改
public Object[] toArray() {
        return Arrays.copyOf(elementData, size);
    }

//根据参数数组类型，复制一份指定参数的数组
@SuppressWarnings("unchecked")
    public <T> T[] toArray(T[] a) {
        if (a.length < size)
            //如果参数数组元素个数小于集合元素个数，就用copyof方法复制
            return (T[]) Arrays.copyOf(elementData, size, a.getClass());
        //否则用arraycopy方法复制，将缓冲数组复制到参数数组中
        System.arraycopy(elementData, 0, a, 0, size);
        //如果参数数组元素个数大于集合元素个数，就让数组的size索引为空
        if (a.length > size)
            a[size] = null;
        //返回参数数组
        return a;
    }

/**
* System中的arraycopy方法
* @ src  源数组 
* @ srcPos 源数组中的起始位置 
* @ dest 目标数组 
* @ destPos 目标数据中的起始位置  
* @ length 要复制的数组元素的数目
*/
public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)

int arr1[] = {0,1,2,3,4,5};
int arr2[] = {0,10,20,30,40,50};
System.arraycopy(arr1,0,arr2,1,2);

//结果：arr2 = [0,0,1,30,40,50]，20和30被覆盖
```

```java
//获取指定索引的元素
@SuppressWarnings("unchecked")
    E elementData(int index) {
        return (E) elementData[index];
    }

//先判断索引是否大于元素个数（越界），再获取指定索引的元素
public E get(int index) {
        rangeCheck(index);
        return elementData(index);
    }

private void rangeCheck(int index) {
        if (index >= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }
//先判断索引是否大于元素个数（越界），再获取指定索引的元素，然后设置指定索引的元素
public E set(int index, E element) {
        rangeCheck(index);

        E oldValue = elementData(index);
        elementData[index] = element;
    //返回指定索引原来的数
        return oldValue;
    }
```

```java
public E remove(int index) {
    //判断索引是否越界
    rangeCheck(index);

    modCount++;
    //获取当前索引的值
    E oldValue = elementData(index);
	//要移动的元素个数
    int numMoved = size - index - 1;
    //当删除最后一个元素的时候不用移动元素
    if (numMoved > 0)
        //将要移动的元素左移一位，删除的本质就是原有元素被覆盖
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    //删除最右边的那个元素
    elementData[--size] = null; // clear to let GC do its work

    return oldValue;
}

//删除第一个对应的对象
public boolean remove(Object o) {
    //如果传入对象为空，就遍历数组，找到对象为空的数组，因为null不能调用函数，所以要分开讨论
        if (o == null) {
            for (int index = 0; index < size; index++)
                if (elementData[index] == null) {
                    fastRemove(index);
                    return true;
                }
            //找到对应的对象
        } else {
            for (int index = 0; index < size; index++)
                if (o.equals(elementData[index])) {
                    fastRemove(index);
                    return true;
                }
        }
    //没找到就返回false
        return false;
    }
//与remove方法一样
private void fastRemove(int index) {
        modCount++;
        int numMoved = size - index - 1;
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work
    }

public void clear() {
        modCount++;

        // clear to let GC do its work
    //将数组的所有元素置为null
        for (int i = 0; i < size; i++)
            elementData[i] = null;
	//元素个数置为0
        size = 0;
    }

//添加集合到ArrayList中
public boolean addAll(Collection<? extends E> c) {
    //先把集合转成数组
        Object[] a = c.toArray();
    //获取数组元素个数
        int numNew = a.length;
    //判断是否要扩容
        ensureCapacityInternal(size + numNew);  // Increments modCount
    //将该object数组复制到缓冲数组的最后
        System.arraycopy(a, 0, elementData, size, numNew);
    //元素个数为二者之和
        size += numNew;
    //如果传过来的是一个空数组，就返回false
        return numNew != 0;
    }

//添加集合到指定索引，与上述方法不同的是要移动元素
public boolean addAll(int index, Collection<? extends E> c) {
        rangeCheckForAdd(index);

        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacityInternal(size + numNew);  // Increments modCount

        int numMoved = size - index;
        if (numMoved > 0)
            //先进行缓冲数组自我复制，为object数组腾出位置
            System.arraycopy(elementData, index, elementData, index + numNew,
                             numMoved);
	//将object数组复制过来
        System.arraycopy(a, 0, elementData, index, numNew);
        size += numNew;
        return numNew != 0;
    }
//删除索引范围内的元素[fromIndex,toIndex)
protected void removeRange(int fromIndex, int toIndex) {
        modCount++;
        int numMoved = size - toIndex;
        System.arraycopy(elementData, toIndex, elementData, fromIndex,
                         numMoved);

        // clear to let GC do its work
        int newSize = size - (toIndex-fromIndex);
        for (int i = newSize; i < size; i++) {
            elementData[i] = null;
        }
        size = newSize;
    }

//返回索引和元素个数
private String outOfBoundsMsg(int index) {
        return "Index: "+index+", Size: "+size;
    }

//删除指定集合
public boolean removeAll(Collection<?> c) {
    //如果为空就会抛出异常
        Objects.requireNonNull(c);
        return batchRemove(c, false);
    }
//仅保留此列表中包含在指定集合中的元素
 public boolean retainAll(Collection<?> c) {
        Objects.requireNonNull(c);
        return batchRemove(c, true);
    }

private boolean batchRemove(Collection<?> c, boolean complement) {
        final Object[] elementData = this.elementData;
        int r = 0, w = 0;
        boolean modified = false;
        try {
            for (; r < size; r++)
                //判断是否包含元素，来修改元素
                if (c.contains(elementData[r]) == complement)
                    //从0开始重写数组
                    elementData[w++] = elementData[r];
        } finally {
            // Preserve behavioral compatibility with AbstractCollection,
            // even if c.contains() throws.
            if (r != size) {
                System.arraycopy(elementData, r,elementData, w,size - r);
                w += size - r;
            }
            if (w != size) {
                // clear to let GC do its work
                //将w后的元素都置空
                for (int i = w; i < size; i++)
                    elementData[i] = null;
                modCount += size - w;
                size = w;
                modified = true;
            }
        }
        return modified;
    }
```

序列化的目的是节省空间

```java
//实现接口Serializable的方法.
//在序列化和反序列化过程中需要特殊处理的类必须使用下列准确签名来实现特殊方法：
//private void writeObject(java.io.ObjectOutputStream out) throws IOException
//private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException

private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException{
        // Write out element count, and any hidden stuff
        int expectedModCount = modCount;
        s.defaultWriteObject();

        // Write out size as capacity for behavioural compatibility with clone()
        s.writeInt(size);

        // 将集合内的元素写到输出流中
        for (int i=0; i<size; i++) {
            s.writeObject(elementData[i]);
        }

        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
    }

private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {
        elementData = EMPTY_ELEMENTDATA;//先将elementData置为空数组

        // Read in size, and any hidden stuff
        s.defaultReadObject();

        // Read in capacity
        s.readInt(); // ignored

        if (size > 0) {
            // be like clone(), allocate array based upon size not capacity
            int capacity = calculateCapacity(elementData, size);
            SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);
            ensureCapacityInternal(size);

            Object[] a = elementData;
            // Read in all elements in the proper order.
            for (int i=0; i<size; i++) {
                a[i] = s.readObject();//从流中读取，进行数组赋值
            }
        }
    }

```

ArrayList的集合是按元素个数（size）进行增删改查的，但数组的大小（容量）通常是比size大的

```java
(1)private class Itr implements Iterator<E>  
(2)private class ListItr extends Itr implements ListIterator<E>  
(3)private class SubList extends AbstractList<E> implements RandomAccess  
(4)static final class ArrayListSpliterator<E> implements Spliterator<E>  
```

ArrayList有四个内部类

**Itr是实现了Iterator接口**，同时重写了里面的**hasNext()**， **next()**， **remove()** 等方法；

**ListItr** 继承 **Itr**，实现了**ListIterator接口**，同时重写了**hasPrevious()**， **nextIndex()**， **previousIndex()**， **previous()**， **set(E e)**， **add(E e)** 等方法

**Iterator和ListIterator的区别:** ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。

```java
for(int i=0;i<list.size();i++){
    list.remove(...);//list.size()会发生改变，这样删除会报错
}
//应该使用迭代器
while (it.hasNext())
{
    it.next();//遍历元素
    it.remove();//删除元素
}
```

### LinkedList

继承了AbstractSequentialList，实现了List，Deque（双端队列），Cloneable，Serializable，是双向链表

```java
//内部节点类
private static class Node<E> {
        E item;//节点值
        Node<E> next;//后继节点
        Node<E> prev;//前驱节点

        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
    
transient int size = 0;//集合元素个数
transient Node<E> first;//第一个元素
transient Node<E> last;//最后一个元素

public LinkedList() {
    }

//带集合的构造方法
public LinkedList(Collection<? extends E> c) {
        this();
        addAll(c);
    }
//将集合添加到链表末尾
public boolean addAll(Collection<? extends E> c) {
        return addAll(size, c);
    }
//向指定索引添加集合
public boolean addAll(int index, Collection<? extends E> c) {
    //判断索引是否在0-元素个数的范围内
        checkPositionIndex(index);
	//将集合转为数组
        Object[] a = c.toArray();
        int numNew = a.length;
        if (numNew == 0)
            return false;
	//前驱节点和后继节点
        Node<E> pred, succ;
    //如果索引为链表末端，后继节点为null，前驱节点为最后一个元素
        if (index == size) {
            succ = null;
            pred = last;
    //否则后继节点为指定索引的节点，前驱节点为指定索引的节点的前驱节点，也就是把集合插到两个元素之间
        } else {
            succ = node(index);
            pred = succ.prev;
        }

        for (Object o : a) {
            //遍历数组中的元素
            @SuppressWarnings("unchecked") E e = (E) o;
            //新建一个值为前驱节点为前驱节点，值为当前元素，后继节点为null的节点
            Node<E> newNode = new Node<>(pred, e, null);
            if (pred == null)//如果前驱节点为空（链表为空），链表的第一个元素就是这个新节点
                first = newNode;
            else//否则让前驱节点的下一个节点为新节点（双向链表需要双向绑定）
                pred.next = newNode;
            pred = newNode;//遍历到下一节点
        }
    //最后还差后继节点未绑定
	//如果后继节点为空，赋值最后一个元素
        if (succ == null) {
            last = pred;
        } else {//否则与后继节点相互绑定
            pred.next = succ;
            succ.prev = pred;
        }
	
        size += numNew;
        modCount++;
        return true;
    }
//判断索引是否在范围内
private void checkPositionIndex(int index) {
        if (!isPositionIndex(index))
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }
 private boolean isPositionIndex(int index) {
        return index >= 0 && index <= size;//可以等于元素个数，即可以在末端添加新元素
    }

//判断索引是否越界
private void checkElementIndex(int index) {
        if (!isElementIndex(index))
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }
private boolean isElementIndex(int index) {
        return index >= 0 && index < size;//不可以等于元素个数
    }

//返回当前索引的节点
Node<E> node(int index) {
    //如果索引小于元素个数的一半
        if (index < (size >> 1)) {
            //从第一个元素开始遍历
            Node<E> x = first;
            for (int i = 0; i < index; i++)
                x = x.next;
            return x;
        } else {//否则从最后一个元素往前遍历
            Node<E> x = last;
            for (int i = size - 1; i > index; i--)
                x = x.prev;
            return x;
        }
    }
```

```java
//添加元素至链表的首位
public void addFirst(E e) {
        linkFirst(e);
    }
private void linkFirst(E e) {
        final Node<E> f = first;
    //创建一个新节点，前驱节点为null，后继节点为第一个元素
        final Node<E> newNode = new Node<>(null, e, f);
    //第一个元素为新节点
        first = newNode;
    //如果这个链表原来是空链表
        if (f == null)
            //最后一个元素也是新节点
            last = newNode;
    //否则第一个元素的前驱节点为新节点
        else
            f.prev = newNode;
        size++;
        modCount++;
    }

//添加元素至链表的末位
public void addLast(E e) {
        linkLast(e);
    }
void linkLast(E e) {
        final Node<E> l = last;
        final Node<E> newNode = new Node<>(l, e, null);
        last = newNode;
        if (l == null)
            first = newNode;
        else
            l.next = newNode;
        size++;
        modCount++;
    }
//添加元素也是至链表末位
public boolean add(E e) {
        linkLast(e);
        return true;
    }

public void add(int index, E element) {
    //判断索引是否在范围内
        checkPositionIndex(index);
	//如果索引等于元素个数，就将其加到链表末端
        if (index == size)
            linkLast(element);
        else
            //向指定索引的节点前加入新元素
            linkBefore(element, node(index));
    }
//添加一个元素到一个节点前
//先得到之前的前驱节点，然后设置新节点的前驱节点和后继节点，最后设置之前的前驱节点的后继节点为新节点，之前的后继节点的前驱节点为新节点
 void linkBefore(E e, Node<E> succ) {
        // succ一定不能为空！
        final Node<E> pred = succ.prev;
        final Node<E> newNode = new Node<>(pred, e, succ);
        succ.prev = newNode;
     //如果原来只有一个节点，就让第一个元素为新节点
        if (pred == null)
            first = newNode;
        else
            pred.next = newNode;
        size++;
        modCount++;
    }
```

```java
//删除第一个元素
 private E unlinkFirst(Node<E> f) {
     // 参数应为第一个元素且不为空
     //获得第一个元素的值和后继节点
        final E element = f.item;
        final Node<E> next = f.next;
     //将元素值置为空，后继节点置为空，第一个元素改为后继节点
        f.item = null;
        f.next = null; // help GC
        first = next;
     //如果后继节点也为空，最后一个元素也为空，整个链表都为空了
        if (next == null)
            last = null;
        else//后继节点的前驱节点为空，彻底删除第一个元素
            next.prev = null;
     //元素数-1
        size--;
        modCount++;
        return element;
    }
 public E removeFirst() {
        final Node<E> f = first;
        if (f == null)
            throw new NoSuchElementException();
        return unlinkFirst(f);
    }

//删除最后一个元素
private E unlinkLast(Node<E> l) {
        // assert l == last && l != null;
        final E element = l.item;
        final Node<E> prev = l.prev;
        l.item = null;
        l.prev = null; // help GC
        last = prev;
        if (prev == null)
            first = null;
        else
            prev.next = null;
        size--;
        modCount++;
        return element;
    }
public E removeLast() {
        final Node<E> l = last;
        if (l == null)
            throw new NoSuchElementException();
        return unlinkLast(l);
    }

//删除一个节点
E unlink(Node<E> x) {
        // assert x != null;
        final E element = x.item;
        final Node<E> next = x.next;
        final Node<E> prev = x.prev;
	//删除前驱节点和后置节点
        if (prev == null) {
            first = next;
        } else {
            prev.next = next;
            x.prev = null;
        }

        if (next == null) {
            last = prev;
        } else {
            next.prev = prev;
            x.next = null;
        }
	//删除值
        x.item = null;
        size--;
        modCount++;
        return element;
    }
//删除第一个出现的指定的元素
public boolean remove(Object o) {
    //因为不知道具体索引，都是从头开始查找
        if (o == null) {
            for (Node<E> x = first; x != null; x = x.next) {
                if (x.item == null) {
                    unlink(x);
                    return true;
                }
            }
        } else {
            for (Node<E> x = first; x != null; x = x.next) {
                if (o.equals(x.item)) {
                    unlink(x);
                    return true;
                }
            }
        }
        return false;
    }

//删除所有元素
public void clear() {
        // Clearing all of the links between nodes is "unnecessary", but:
        // - helps a generational GC if the discarded nodes inhabit
        //   more than one generation
        // - is sure to free memory even if there is a reachable Iterator
        for (Node<E> x = first; x != null; ) {
            //先作为临时值存储后继节点
            Node<E> next = x.next;
            x.item = null;
            x.next = null;
            x.prev = null;
            x = next;
        }
        first = last = null;
        size = 0;
        modCount++;
    }
```

```java
//获取第一个元素
public E getFirst() {
        final Node<E> f = first;
        if (f == null)
            throw new NoSuchElementException();
        return f.item;
    }

//获取最后一个元素
public E getLast() {
        final Node<E> l = last;
        if (l == null)
            throw new NoSuchElementException();
        return l.item;
    }
//获取指定索引的元素
public E get(int index) {
        checkElementIndex(index);
        return node(index).item;
    }
//设置指定索引的元素
public E set(int index, E element) {
        checkElementIndex(index);
        Node<E> x = node(index);
        E oldVal = x.item;
        x.item = element;
        return oldVal;
    }
//判断元素是否存在
public boolean contains(Object o) {
        return indexOf(o) != -1;
    }
//获得指定元素第一次出现时的索引，从头开始找，找不到返回-1
 public int indexOf(Object o) {
        int index = 0;
        if (o == null) {
            for (Node<E> x = first; x != null; x = x.next) {
                if (x.item == null)
                    return index;
                index++;
            }
        } else {
            for (Node<E> x = first; x != null; x = x.next) {
                if (o.equals(x.item))
                    return index;
                index++;
            }
        }
        return -1;
    }
//获得指定元素最后一次出现时的索引，从末开始找
public int lastIndexOf(Object o) {
        int index = size;
        if (o == null) {
            for (Node<E> x = last; x != null; x = x.prev) {
                index--;
                if (x.item == null)
                    return index;
            }
        } else {
            for (Node<E> x = last; x != null; x = x.prev) {
                index--;
                if (o.equals(x.item))
                    return index;
            }
        }
        return -1;
    }

//返回元素个数
public int size() {
        return size;
    }

//输出index和size
private String outOfBoundsMsg(int index) {
        return "Index: "+index+", Size: "+size;
    }

```

其他必须实现Deque接口的方法，但有些与上述方法重复：

```java
public E element() {
        return getFirst();
    }

//获取第一个元素的值，这个能返回null，getFirst遇到null会抛出异常
public E peek() {
        final Node<E> f = first;
        return (f == null) ? null : f.item;
    }
public E peekFirst() {
        final Node<E> f = first;
        return (f == null) ? null : f.item;
     }
//获取最后一个元素的值
public E peekLast() {
        final Node<E> l = last;
        return (l == null) ? null : l.item;
    }
//删除第一个元素，第一个元素可以为null
 public E poll() {
        final Node<E> f = first;
        return (f == null) ? null : unlinkFirst(f);
    }
public E pollFirst() {
        final Node<E> f = first;
        return (f == null) ? null : unlinkFirst(f);
    }
//删除最后一个元素
public E pollLast() {
        final Node<E> l = last;
        return (l == null) ? null : unlinkLast(l);
    }
//删除第一个元素
public E remove() {
        return removeFirst();
    }
public E pop() {
        return removeFirst();
    }
//删除第一次出现的指定的对象
public boolean removeFirstOccurrence(Object o) {
        return remove(o);
    }
//删除最后一次出现的指定的对象，这个方法之前没出现过
public boolean removeLastOccurrence(Object o) {
        if (o == null) {
            for (Node<E> x = last; x != null; x = x.prev) {
                if (x.item == null) {
                    unlink(x);
                    return true;
                }
            }
        } else {
            for (Node<E> x = last; x != null; x = x.prev) {
                if (o.equals(x.item)) {
                    unlink(x);
                    return true;
                }
            }
        }
        return false;
    }
//插入元素
public boolean offer(E e) {
        return add(e);
    }
//在首部插入元素
public boolean offerFirst(E e) {
        addFirst(e);
        return true;
    }
public void push(E e) {
        addFirst(e);
    }
//在末尾插入元素
public boolean offerLast(E e) {
        addLast(e);
        return true;
    }
```

克隆

```java
private LinkedList<E> superClone() {
        try {
            return (LinkedList<E>) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new InternalError(e);
        }
    }
//浅拷贝，对自己的node都作了new操作，但对每个Node中的对象并没有作new操作
 public Object clone() {
        LinkedList<E> clone = superClone();

        //克隆对象初始化
        clone.first = clone.last = null;
        clone.size = 0;
        clone.modCount = 0;

        // 将元素赋值到新克隆的对象中
        for (Node<E> x = first; x != null; x = x.next)
            clone.add(x.item);

        return clone;
    }
```

转数组

```java
public Object[] toArray() {
    //新建一个数组来接收值
        Object[] result = new Object[size];
        int i = 0;
        for (Node<E> x = first; x != null; x = x.next)
            result[i++] = x.item;
        return result;
    }
    //转化为参数类型的数组
    @SuppressWarnings("unchecked")
    public <T> T[] toArray(T[] a) {
        //如果a的元素个数小于链表的元素个数，就重新创建一个数组赋给a
        if (a.length < size)
            a = (T[])java.lang.reflect.Array.newInstance(
                                a.getClass().getComponentType(), size);
        int i = 0;
        Object[] result = a;
        //等同于将链表中的值赋给a，因为result和a都指向同一个地址
        for (Node<E> x = first; x != null; x = x.next)
            result[i++] = x.item;

        if (a.length > size)
            a[size] = null;

        return a;
    }
```

序列化，结点中持有前驱结点和后继结点的引用，引用就是对象在内存中的地址值。对于这样的结点形成的链表，序列化这个链表后，结点的前序和后继引用都失效了，因为**内存地址变了**。所以需要**重新连接链表**。

```java
private static final long serialVersionUID = 876323262645176354L;
private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException {
        // Write out any hidden serialization magic
        s.defaultWriteObject();

        // Write out size
        s.writeInt(size);

        // Write out all elements in the proper order.
        for (Node<E> x = first; x != null; x = x.next)
            s.writeObject(x.item);
    }
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
        // Read in any hidden serialization magic
        s.defaultReadObject();

        // Read in size
        int size = s.readInt();

        // Read in all elements in the proper order.
        for (int i = 0; i < size; i++)
            linkLast((E)s.readObject());
    }
```

### HashMap

hash指的是把**任意长度**的输入，通过散列算法变换成**固定长度**的输出，该输出就是散列值，**不同的输入**可能会散列成相同的输出，不能从散列值来唯一的确定输入值。两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做**碰撞**。

常见的解决碰撞的方法：

- 开放定址法：一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。
- 链地址法：将哈希表的每个单元作为链表的头结点，所有哈希地址相同的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。
- 再哈希法：用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。
- 建立公共溢出区：将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。

在HashMap中，hash()方法的功能就是根据Key来定位其在HashMap中的位置

JDK1.8 之前 HashMap 由 **数组+链表** 组成的，数组是 HashMap  的主体（一个key的索引是hash(key)&n，n为数组长度），**链表则是主要为了解决哈希冲突**而存在的（“拉链法”解决冲突）。**使用扰动函数（hash()方法）之后可以减少碰撞。**

创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。

```java
//将Object转换成一个整型
final int hash(Object k) {
    int h = hashSeed;
    if (0 != h && k instanceof String) {
        return sun.misc.Hashing.stringHash32((String) k);
    }

    h ^= k.hashCode();
    h ^= (h >>> 20) ^ (h >>> 12);
    return h ^ (h >>> 7) ^ (h >>> 4);
}
//将hash生成的整型转换成链表数组中的下标，h & (length-1)=h % length，位运算效率高于模运算
static int indexFor(int h, int length) {
    return h & (length-1);
}
```

JDK1.8 以后，当**链表长度大于阈值（默认为 8）时**，将**链表转化为红黑树**（将链表转换成红黑树前会判断，如果当前数组的长度小于  64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

```java
public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable {
	// 初始容量为16
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;   
    // 最大容量为2的30次方
    static final int MAXIMUM_CAPACITY = 1 << 30; 
    // 默认的加载因子
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    // 当桶(bucket)上的结点数大于这个值时转换成红黑树
    static final int TREEIFY_THRESHOLD = 8; 
    // 当桶上的结点数小于这个值时树转链表
    static final int UNTREEIFY_THRESHOLD = 6;
    // 转化为红黑树时，对应的table的最小大小
    static final int MIN_TREEIFY_CAPACITY = 64;
    // 存储元素的数组，总为2的幂次倍
    transient Node<k,v>[] table; 
    // 存放具体元素的集合
    transient Set<Map.Entry<k,v>> entrySet;
    // 元素的个数，注意这个不等于数组的长度。
    transient int size;
    // 每次扩容和更改map结构的计数器
    transient int modCount;   
    // 临界值
    int threshold;
    // 加载因子，控制数组存放数据的疏密程度，越趋近于1，数组中存放的数据(entry)越多。越趋近于0，数组中存放的数据越少
    final float loadFactor;    
```

```java
//节点类
    static class Node<K,V> implements Map.Entry<K,V> {
        // 哈希值、键、值、后继节点
        final int hash;
        final K key;
        V value;
        Node<K,V> next;

        Node(int hash, K key, V value, Node<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }
		//获取键、值、重写toString方法
        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + "=" + value; }
		//重写hashCode方法
        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }
		//设置值，返回的是老值
        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }
		//重写equals方法，如果地址相同，或者如果这个对象是map的一个元素，且键和值与本对象相等，就是相等的
        public final boolean equals(Object o) {
            if (o == this)
                return true;
            if (o instanceof Map.Entry) {
                Map.Entry<?,?> e = (Map.Entry<?,?>)o;
                if (Objects.equals(key, e.getKey()) &&
                    Objects.equals(value, e.getValue()))
                    return true;
            }
            return false;
        }
    }
    
   
```

```java
 //树节点
    static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {
        //父节点，左子节点，右子节点，颜色
        TreeNode<K,V> parent; 
        TreeNode<K,V> left;
        TreeNode<K,V> right;
        boolean red;
        TreeNode(int hash, K key, V val, Node<K,V> next) {
            super(hash, key, val, next);
        }
        // 返回根节点
        final TreeNode<K,V> root() {
            //遍历树节点，如果当前节点的父节点为空，当前节点就是根节点，否则父节点为当前节点
            for (TreeNode<K,V> r = this, p;;) {
                if ((p = r.parent) == null)
                    return r;
                r = p;
       }
```

```java
//默认构造函数
public HashMap() {
    //加载因子为0.75f
        this.loadFactor = DEFAULT_LOAD_FACTOR; 
    }
//指定容量的构造函数
public HashMap(int initialCapacity) {
    //加载因子为0.75f
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }
//指定容量和加载因子的构造函数
public HashMap(int initialCapacity, float loadFactor) {
    //检测指定容量是否小于0或大于最大容量，如果大于最大容量，初始容量就为最大容量
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal initial capacity: " +
                                               initialCapacity);
        if (initialCapacity > MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
    //如果加载因子小于0，或者不是数字，就抛出异常
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " +
                                               loadFactor);
    //赋值加载因子、临界值
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }
//临界值的计算方法，如果本身就为2的次方，就不变，如果不是，就扩容到2的次方
static final int tableSizeFor(int cap) {
        int n = cap - 1;//为了后面+1的操作，要先-1
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;//让n的第一个1后也全为1
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;//+1后为2的幂次方
    }
//参数为Map集合的构造方法
public HashMap(Map<? extends K, ? extends V> m) {
    //加载因子为0.75
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        putMapEntries(m, false);
    }
final void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) {
        int s = m.size();//获取键值对个数
        if (s > 0) {
            //如果待构造集合没有元素
            if (table == null) {
                //键值对个数/加载因子+1，如果这个值小于最大容量，就赋值给t，否则t为最大容量
                float ft = ((float)s / loadFactor) + 1.0F;
                int t = ((ft < (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY);
                //如果t大于临界值，令t为容量，重新计算临界值
                if (t > threshold)
                    threshold = tableSizeFor(t);
            }else if (s > threshold)//如果已经有元素，且新的元素个数大于临界值，就扩容
                resize();
            //遍历集合，加入到当前集合中
            for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {
                K key = e.getKey();
                V value = e.getValue();
                putVal(hash(key), key, value, false, evict);
            }
        }
    }
```

```java
//put方法
public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) {
        Node<K,V>[] tab; Node<K,V> p; int n, i;//链表数组，当前索引的节点，数组的长度
    //赋值当前数组给链表数组，如果没有元素，进行扩容
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
    //(n - 1) & hash 确定元素存放在数组的哪个索引中，如果这个索引对应的值为空
        if ((p = tab[i = (n - 1) & hash]) == null)
            //新建一个节点，赋给该值
            tab[i] = newNode(hash, key, value, null);
    //如果已经有值（链表的第一个节点）
        else {
            Node<K,V> e; K k;
            //如果第一个节点与存入元素的hash和key相等，说明遇到重复值，赋值给临时节点
            if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;
            //如果不相等，但第一个节点属于红黑树节点，就将键和值添加到红黑树中
            else if (p instanceof TreeNode)
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            //否则为链表的第一个节点
            else {
                //以键和值新建一个节点，加到链表的末尾
                for (int binCount = 0; ; ++binCount) {//统计节点数量
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        //如果节点数量超过阈值，转换为红黑树
                        if (binCount >= TREEIFY_THRESHOLD - 1) 
                            treeifyBin(tab, hash);
                        break;
                    }
                    //如果hash和key相等，说明遇到重复值，直接跳出循环
                    if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
                }
            }
            //说明遇到了重复值，用新值替换旧值
            if (e != null) { 
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
    //元素个数+1，如果大于临界值，就扩容
        if (++size > threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }

//jdk1.7的put方法，如果定位到的数组位置没有元素 就直接插入。
//如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插法插入元素。
```

```java
//get方法
public V get(Object key) {
        Node<K,V> e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }
final Node<K,V> getNode(int hash, Object key) {
        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
    //如果数组不为空，且hash对应的索引不为空
        if ((tab = table) != null && (n = tab.length) > 0 &&(first = tab[(n - 1) & hash]) != null) {
            //遇到重复值，说明第一个节点就是要找的值
            if (first.hash == hash && ((k = first.key) == key || (key != null && key.equals(k))))
                return first;
            //如果下一节点不为空
            if ((e = first.next) != null) {
                //如果第一个节点属于红黑树节点，在红黑树中进行get
                if (first instanceof TreeNode)
                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);
                //遍历链表，直到找到重复值，返回这个重复值的节点
                do {
                    if (e.hash == hash &&((k = e.key) == key || (key != null && key.equals(k))))
                        return e;
                } while ((e = e.next) != null);
            }
        }
        return null;
    }
```

```java
//扩容，非常耗时，要尽量避免
final Node<K,V>[] resize() {
    Node<K,V>[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    //如果有元素
    if (oldCap > 0) {
        // 如果旧容量已经是最大容量了，就让临界值等于最大值，直接返回旧数组
        if (oldCap >= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        // 没超过最大值且旧容量>=16，旧容量扩充为原来的2倍，新的临界值也为原来的2倍
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr << 1; // double threshold
    }
    //如果没有元素，但旧临界值大于0，就让临界值为新容量
    else if (oldThr > 0) 
        newCap = oldThr;
    //如果临界值也小于0，就让新容量为16，新临界值为16*0.75=12
    else { 
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    // 如果新临界值为0，就让新容量*加载因子，赋值给新临界值
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);
    }
    //临界值为新临界值
    threshold = newThr;
    @SuppressWarnings({"rawtypes","unchecked"})
    //新数组为大小为新容量的数组
    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
    //数组为新数组
    table = newTab;
    if (oldTab != null) {
        // 把旧数组的元素拷贝到新数组中，并把旧数组的元素置空
        for (int j = 0; j < oldCap; ++j) {
            Node<K,V> e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null;
                //如果是链表只有1个元素，就直接赋值给数组
                if (e.next == null)
                    newTab[e.hash & (newCap - 1)] = e;
                //如果是红黑树节点
                else if (e instanceof TreeNode)
                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                //如果链表有多个元素
                else { 
                    Node<K,V> loHead = null, loTail = null;
                    Node<K,V> hiHead = null, hiTail = null;
                    Node<K,V> next;
                    do {
                        next = e.next;
                        // 如果原表的索引没有改变
                        if ((e.hash & oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        // 如果原表的索引改变
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);

                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }

                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}
```
